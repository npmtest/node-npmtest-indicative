{"/home/travis/build/npmtest/node-npmtest-indicative/test.js":"/* istanbul instrument in package npmtest_indicative */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-indicative/lib.npmtest_indicative.js":"/* istanbul instrument in package npmtest_indicative */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_indicative = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_indicative = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-indicative/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-indicative && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_indicative */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_indicative\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_indicative.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_indicative.rollup.js'] =\n            local.assetsDict['/assets.npmtest_indicative.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_indicative.__dirname + '/lib.npmtest_indicative.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-indicative/node_modules/indicative/index.js":"'use strict'\n\n/**\n * indicative\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n*/\nconst Validator = require('./src/Validator')\nconst Sanitization = require('./src/Sanitization')\n\nmodule.exports = {\n  validate: Validator.validate,\n  validateAll: Validator.validateAll,\n  extend: Validator.extend,\n  is: Validator.is,\n  'is.extend': Validator.is.extend,\n  sanitize: Sanitization.sanitize,\n  sanitizor: Sanitization.sanitizor,\n  'sanitizor.extend': Sanitization.sanitizor.extend\n}\n","/home/travis/build/npmtest/node-npmtest-indicative/node_modules/indicative/src/Validator/index.js":"'use strict'\n\n/**\n * indicative\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n*/\n\nconst _ = require('lodash')\nconst Parser = require('../Parser')\nconst Validations = require('../Validations')\nconst ValidationEngine = require('./engine')\nconst Messages = require('../Messages')\nconst Modes = require('../Modes')\nconst Q = require('q')\n\n/**\n * map all parsedRules into a validation messages to be executed\n * using Q.\n *\n * @param   {Object} data\n * @param   {Object} rules\n * @param   {Object} messages\n *\n * @return  {Array}\n *\n * @private\n */\nfunction _mapValidations (data, rules, messages, runAll) {\n  return _.map(rules, (validations, field) => ValidationEngine.validateField(data, field, validations, messages, runAll))\n}\n\n/**\n * it manually maps all the errors returned by Q.allSettled\n * and throws them as an array only if there are errors.\n *\n * @param  {Array} results\n *\n * @return {void}\n * @throws {Error} If promise resolves to errors or a single error\n *\n * @private\n */\nfunction _settleAllPromises (results) {\n  const errors = _(results)\n  .flatten()\n  .map((result) => {\n    return result.state === 'rejected' ? result.reason : null\n  })\n  .compact()\n  .value()\n  if (_.size(errors)) {\n    throw errors\n  }\n}\n\nconst Validator = exports = module.exports = {}\n\n/**\n * validate a set of async validations mapped as field and rule\n * called rules.\n *\n * @param  {Object} data\n * @param  {Object} rules\n * @param  {Object} messages\n *\n * @return {Object|Array}\n */\n\nValidator.validate = function (data, rules, messages) {\n  messages = messages || {}\n  const transformedRules = Parser.transformRules(data, rules)\n  const validations = _mapValidations(data, transformedRules, messages)\n\n  return Q.Promise((resolve, reject) => {\n    Q.all(validations)\n    .then(() => resolve(data))\n    .catch((error) => reject([error]))\n  })\n}\n\n/**\n * Just like validate but waits for all the validations to occur\n * and returns an array of errors.\n *\n * @param  {Object} data\n * @param  {Object} rules\n * @param  {Object} messages\n *\n * @return {Object|Array}\n */\nValidator.validateAll = function (data, rules, messages) {\n  messages = messages || {}\n  const transformedRules = Parser.transformRules(data, rules)\n  const validations = _mapValidations(data, transformedRules, messages, true)\n\n  return Q.Promise((resolve, reject) => {\n    Q.all(validations)\n    .then(_settleAllPromises)\n    .then(() => resolve(data))\n    .catch(reject)\n  })\n}\n\n/**\n * exposes an interface to extend the validator and add\n * new methods to it.\n *\n * @param  {String} name\n * @param  {Function} method\n * @param  {String} message\n *\n * @return {void}\n *\n * @throws {Error} If method is not a function\n */\nValidator.extend = function (name, method, message) {\n  if (typeof (method) !== 'function') {\n    throw new Error('Invalid arguments, extend expects a method to execute')\n  }\n  Validations[name] = method\n  Messages.set(_.snakeCase(name), message)\n}\n\nValidator.is = require('../Raw')\n\n/**\n * exposes an interface to extend the raw validator and add\n * own methods to it.\n *\n * @param  {String} name\n * @param  {Function} method\n *\n * @return {void}\n *\n * @throws {Error} If method is not a function\n */\nValidator.is.extend = function (name, method) {\n  if (typeof (method) !== 'function') {\n    throw new Error('Invalid arguments, is.extends expects 2nd parameter as a function')\n  }\n  Validator.is[name] = method\n}\n\n/**\n * @see Modes.set\n */\nValidator.setMode = Modes.set\n","/home/travis/build/npmtest/node-npmtest-indicative/node_modules/indicative/src/Parser/index.js":"'use strict'\n\n/**\n * indicative\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n*/\n\nconst arrayExpressionRegex = /(\\w[^\\.\\*]+)(\\.\\*\\.?)(.+)?/\nconst _ = require('lodash')\n\nlet Parser = exports = module.exports = {}\n\n/**\n * parse a validation validation string to fetch\n * args from it.\n *\n * @param   {String} validation\n *\n * @return  {Object}\n *\n * @private\n */\nconst _parseValidation = function (validation) {\n  return _(validation.split(':'))\n  .thru((value) => {\n    const args = value[1] ? value[1].split(',') : []\n    return {name: value[0], args}\n  })\n  .value()\n}\n\n/**\n * parse all validation strings to object.\n *\n * @param   {Array} validations\n *\n * @return  {Array}\n *\n * @private\n */\nconst _parseValidations = function (validations) {\n  return _.map(validations, (validation) => {\n    return _parseValidation(validation)\n  })\n}\n\n/**\n * parse a given set of validations to a consumable array.\n *\n * @param  {String|Array} rule\n *\n * @return {Array}\n */\nParser.parse = function (validations) {\n  const validationsArray = validations instanceof Array ? validations : validations.split('|')\n  return _parseValidations(validationsArray)\n}\n\n/**\n * parses an array expression to a consumable object\n *\n * @param  {String} field\n * @return {Object|Null}\n *\n * @public\n */\nParser.expressionCurryFor = function (field, whenMatched, otherwise) {\n  const expression = field.match(arrayExpressionRegex)\n  if (_.size(expression) < 4) {\n    return otherwise()\n  }\n  return whenMatched(expression[1], expression[3])\n}\n\n/**\n * parses a rule and returns an object with\n * field name and parsed rule.\n *\n * @param   {String} rule\n * @param   {String} field\n *\n * @return  {Object}\n *\n * @private\n */\nParser.parseFieldRule = function (rule, field) {\n  return {[field]: Parser.parse(rule)}\n}\n\n/**\n * parses field rules for a array expressions\n *\n * @param   {Object} data\n * @param   {String} rule\n * @param   {String} node\n * @param   {String} [child]\n *\n * @return  {Object}\n *\n * @private\n */\nParser.getRulesForExpression = function (data, rule, node, child) {\n  return _.fromPairs(_.map(data[node], (value, index) => {\n    const fieldName = _([node, index, child]).takeWhile((value) => value !== undefined).join('.')\n    return [fieldName, Parser.parse(rule)]\n  }))\n}\n\n/**\n * transforms a single rule or an array expression\n * into multiple rules\n *\n * @param   {Object} data\n * @param   {String} rule\n * @param   {String} field\n *\n * @return  {Object}\n *\n * @private\n */\nParser.transformRule = function (data, rule, field) {\n  return Parser.expressionCurryFor(\n    field,\n    (dataKey, fieldKey) => Parser.getRulesForExpression(data, rule, dataKey, fieldKey),\n    () => Parser.parseFieldRule(rule, field)\n  )\n}\n\n/**\n * transform rules by parsing each rule and converting\n * array expressions into multiple rules\n *\n * @param   {Object} data\n * @param   {Object} rules\n *\n * @return  {Object}\n *\n * @private\n */\nParser.transformRules = function (data, rules) {\n  return _(rules)\n  .transform((result, rule, field) => {\n    _.extend(result, Parser.transformRule(data, rule, field))\n  })\n  .value()\n}\n","/home/travis/build/npmtest/node-npmtest-indicative/node_modules/indicative/src/Validations/index.js":"'use strict'\n\n/**\n * indicative\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n*/\nconst Raw = require('../Raw')\nconst Modes = require('../Modes')\n\n/**\n * @module Validations\n * @description List of schema validations\n * @type {Object}\n */\nlet Validations = exports = module.exports = {}\n\n/**\n * @description figures out whether value can be skipped\n * or not from validation, as non-existing values\n * should be validated using required.\n * @method skippable\n * @param  {Mixed}  value\n * @return {Boolean}\n * @private\n */\nconst skippable = function (value) {\n  return Modes.get() === 'strict' ? typeof (value) === undefined : !Raw.existy(value)\n}\n\n/**\n * @description enforces a field to be confirmed by another.\n * @method email\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.confirmed = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    const confirmedFieldValue = get(data, `${field}_confirmation`)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (Raw.same(fieldValue, confirmedFieldValue)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description enforces a field to be an email if present\n * @method email\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.email = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (Raw.email(fieldValue)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description enforces a field to be accepted\n * @method accepted\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.accepted = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (Raw.truthy(fieldValue)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description enforces a field to be after a certain date\n * @method after\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.after = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (Raw.after(fieldValue, args[0])) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure the value of field under validation is\n * after defined offset\n * @method afterOffsetOf\n * @param  {Object}      data\n * @param  {String}      field\n * @param  {String}      message\n * @param  {Array}      args\n * @param  {Function}      get\n * @return {Object}\n * @public\n */\nValidations.afterOffsetOf = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    const offset = Number(args[0])\n    const key = args[1]\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (Raw.afterOffsetOf(fieldValue, offset, key)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure the value of field under validation is\n * before defined offset\n * @method beforeOffsetOf\n * @param  {Object}      data\n * @param  {String}      field\n * @param  {String}      message\n * @param  {Array}      args\n * @param  {Function}      get\n * @return {Object}\n * @public\n */\nValidations.beforeOffsetOf = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    const offset = Number(args[0])\n    const key = args[1]\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (Raw.beforeOffsetOf(fieldValue, offset, key)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure the field under validation is a\n * valid alpha string\n * @method alpha\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.alpha = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (Raw.alpha(fieldValue) && fieldValue !== null) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure the field under validation is a\n * valid alphaNumeric string\n * @method alphaNumeric\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.alphaNumeric = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (Raw.alphaNumeric(fieldValue) && fieldValue !== null) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure value of field under validation\n * is a valid array\n * @method array\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.array = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (Raw.array(fieldValue)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure value of field under validation\n * is a valid url\n * @method url\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.url = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (Raw.url(fieldValue)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure value of field under validation\n * is a valid object\n * @method object\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.object = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (Raw.object(fieldValue)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure value of field under validation\n * is a valid json string\n * @method json\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.json = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (Raw.json(fieldValue)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure value of field under validation is a\n * valid ip address\n * @method ip\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.ip = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (Raw.ip(fieldValue)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure value of field under validation is a\n * valid ipv4 address\n * @method ipv4\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.ipv4 = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (Raw.ipv4(fieldValue)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure value of field under validation is a\n * valid ipv6 address\n * @method ipv6\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.ipv6 = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (Raw.ipv6(fieldValue)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure value of field under validation is a\n * valid integer\n * @method integer\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.integer = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (Number.isInteger(fieldValue)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure value of field under validation is\n * a boolean\n * @method boolean\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @example\n *   accepts : true,false,0,1,\"0\",\"1\"\n */\nValidations.boolean = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    let fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n\n    /**\n     * converting 0 and 1 strings to numbers\n     */\n    if (fieldValue === '0') {\n      fieldValue = 0\n    } else if (fieldValue === '1') {\n      fieldValue = 1\n    }\n\n    if (Raw.boolean(fieldValue)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure field under validation is before\n * defined date\n * @method before\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.before = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (Raw.before(fieldValue, args[0])) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure field under validation is a valid\n * date\n * @method date\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.date = function (data, field, message, args, get) {\n  const formats = ['MM/DD/YYYY', 'MM-DD-YYYY', 'YYYY-MM-DD', 'YYYY/MM/DD']\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (Raw.dateFormat(fieldValue, formats)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure field under validation is a valid\n * date according to given format\n * @method dateFormat\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.dateFormat = function (data, field, message, args, get) {\n  const format = args[0]\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (Raw.dateFormat(fieldValue, format)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure field value is under defined\n * values\n * @method in\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Boolean}\n * @public\n */\nValidations.in = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (Raw.inArray(fieldValue, args)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure field value is not in one\n * of the defined values\n * @method notIn\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.notIn = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n    if (!Raw.inArray(fieldValue, args)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description enforces a field to be present and should not be\n * null or undefined\n * @method required\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @see  Raw.empty\n * @public\n */\nValidations.required = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (!Raw.empty(fieldValue)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure field under validation is present when\n * conditional field value exists\n * @method requiredIf\n * @param  {Object}   data\n * @param  {String}   field\n * @param  {String}   message\n * @param  {Array}   args\n * @param  {Function}   get\n * @return {Object}\n * @public\n */\nValidations.requiredIf = function (data, field, message, args, get) {\n  const withField = args[0]\n  return new Promise(function (resolve, reject) {\n    const withFieldValue = get(data, withField)\n    if (!withFieldValue) {\n      resolve('validation skipped')\n      return\n    }\n\n    const fieldValue = get(data, field)\n    if (!Raw.empty(fieldValue)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure field under validation is present and\n * value matches to the conditional field value\n * @method requiredWhen\n * @param  {Object}   data\n * @param  {String}   field\n * @param  {String}   message\n * @param  {Array}   args\n * @param  {Function}   get\n * @return {Object}\n * @public\n */\nValidations.requiredWhen = function (data, field, message, args, get) {\n  const withField = args[0]\n  const withfieldExpectedValue = args[1]\n  return new Promise(function (resolve, reject) {\n    const withFieldValue = get(data, withField)\n    if (!withFieldValue || withfieldExpectedValue !== withFieldValue) {\n      resolve('validation skipped')\n      return\n    }\n\n    const fieldValue = get(data, field)\n    if (!Raw.empty(fieldValue)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description enforces field under validation to have data\n * when any of the other expected fields are present\n * @method requiredWithAny\n * @param  {Object}        data\n * @param  {String}        field\n * @param  {String}        message\n * @param  {Array}        args\n * @param  {Function}        get\n * @return {Object}\n * @public\n */\nValidations.requiredWithAny = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    let withFieldCount = 0\n\n    /**\n     * looping through all items to make sure\n     * one of them is present\n     */\n    args.forEach(function (item) {\n      const itemValue = get(data, item)\n      if (itemValue) {\n        withFieldCount++\n        return\n      }\n    })\n\n    if (withFieldCount === 0) {\n      resolve('validation skipped')\n      return\n    }\n\n    const fieldValue = get(data, field)\n    if (!Raw.empty(fieldValue)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description enforces field under validation to have data\n * when any all of the other expected fields are present\n * @method requiredWithAll\n * @param  {Object}        data\n * @param  {String}        field\n * @param  {String}        message\n * @param  {Array}         args\n * @param  {Function}      get\n * @return {Object}\n * @public\n */\nValidations.requiredWithAll = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    let withFieldsCount = 0\n\n    /**\n     * looping through all items to make sure\n     * all of them is present\n     */\n    args.forEach(function (item) {\n      const itemValue = get(data, item)\n      if (itemValue) {\n        withFieldsCount++\n      }\n    })\n\n    if (withFieldsCount !== args.length) {\n      resolve('validation skipped')\n      return\n    }\n\n    const fieldValue = get(data, field)\n    if (!Raw.empty(fieldValue)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description enforces field under validation to have data\n * when any of the other expected fields are missing\n * @method requiredWithoutAny\n * @param  {Object}        data\n * @param  {String}        field\n * @param  {String}        message\n * @param  {Array}        args\n * @param  {Function}        get\n * @return {Object}\n * @public\n */\nValidations.requiredWithoutAny = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    let withOutFieldCounts = 0\n\n    /**\n     * looping through all items to make sure\n     * one of them is present\n     */\n    args.forEach(function (item) {\n      const itemValue = get(data, item)\n      if (!itemValue) {\n        withOutFieldCounts++\n        return\n      }\n    })\n\n    if (withOutFieldCounts === 0) {\n      resolve('validation skipped')\n      return\n    }\n\n    const fieldValue = get(data, field)\n    if (!Raw.empty(fieldValue)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description enforces field under validation to have data\n * when all of the other expected fields are missing\n * @method requiredWithoutAll\n * @param  {Object}        data\n * @param  {String}        field\n * @param  {String}        message\n * @param  {Array}         args\n * @param  {Function}      get\n * @return {Object}\n * @public\n */\nValidations.requiredWithoutAll = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    let withOutFieldCounts = 0\n\n    /**\n     * looping through all items to make sure\n     * one of them is present\n     */\n    args.forEach(function (item) {\n      const itemValue = get(data, item)\n      if (!itemValue) {\n        withOutFieldCounts++\n        return\n      }\n    })\n\n    if (withOutFieldCounts !== args.length) {\n      resolve('validation skipped')\n      return\n    }\n\n    const fieldValue = get(data, field)\n    if (!Raw.empty(fieldValue)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure the value of field under validation\n * matches to the value of targeted field\n * @method same\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.same = function (data, field, message, args, get) {\n  const targetedField = args[0]\n  return new Promise(function (resolve, reject) {\n    const targetedFieldValue = get(data, targetedField)\n    if (!targetedFieldValue) {\n      resolve('validation skipped')\n      return\n    }\n\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n\n    if (targetedFieldValue === fieldValue) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure the value of field under validation\n * does not matches to the value of targeted field\n * @method different\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.different = function (data, field, message, args, get) {\n  const targetedField = args[0]\n  return new Promise(function (resolve, reject) {\n    const targetedFieldValue = get(data, targetedField)\n    if (!targetedFieldValue) {\n      resolve('validation skipped')\n      return\n    }\n\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n\n    if (targetedFieldValue !== fieldValue) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure the value of field under\n * validation is equal to defined value\n * @method equals\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.equals = function (data, field, message, args, get) {\n  const targetedValue = args[0]\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n\n    if (targetedValue == fieldValue) { // eslint-disable-line eqeqeq\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure the value of field under\n * validation is not equal to the defined value\n * @method notEquals\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.notEquals = function (data, field, message, args, get) {\n  const targetedValue = args[0]\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n\n    if (targetedValue !== fieldValue) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure value of field under validation\n * is between a given range\n * @method range\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.range = function (data, field, message, args, get) {\n  const min = args[0]\n  const max = args[1]\n  return new Promise(function (resolve, reject) {\n    if (!min || !max) {\n      return reject('min and max values are required for range validation')\n    }\n\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n\n    if (Raw.between(fieldValue, min, max)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure the length of field under\n * validation is greater than defined length.\n * @method min\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.min = function (data, field, message, args, get) {\n  const minLength = args[0]\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n\n    if (String(fieldValue).length >= minLength) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure the length of field under\n * validation is less than defined length.\n * @method max\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.max = function (data, field, message, args, get) {\n  const maxLength = args[0]\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n\n    if (String(fieldValue).length <= maxLength) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure the value of field under\n * validation is greater than defined value.\n * @method above\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.above = function (data, field, message, args, get) {\n  const minValue = args[0]\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n\n    if (Number(fieldValue) > minValue) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure the value of field under\n * validation is less than defined value.\n * @method under\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.under = function (data, field, message, args, get) {\n  const maxValue = args[0]\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n\n    if (Number(fieldValue) < maxValue) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure value of field under validation contains a\n * given substring\n * @method includes\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.includes = function (data, field, message, args, get) {\n  const substring = args[0]\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n\n    if (String(fieldValue).includes(substring)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure value of field under validation\n * starts with given substring\n * @method startsWith\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.startsWith = function (data, field, message, args, get) {\n  const substring = args[0]\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n\n    if (String(fieldValue).startsWith(substring)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure value of field under validation\n * ends with given substring\n * @method endsWith\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.endsWith = function (data, field, message, args, get) {\n  const substring = args[0]\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n\n    if (String(fieldValue).endsWith(substring)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure field under validation satifies defined\n * regex\n * @method regex\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.regex = function (data, field, message, args, get) {\n  const regexExp = args[0]\n  const regexFlags = args[1]\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n\n    const expression = regexFlags ? new RegExp(regexExp, regexFlags) : new RegExp(regexExp)\n    if (Raw.regex(fieldValue, expression)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * @description makes sure field under validation is a string\n * @method regex\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} message\n * @param  {Array} args\n * @param  {Function} get\n * @return {Object}\n * @public\n */\nValidations.string = function (data, field, message, args, get) {\n  return new Promise(function (resolve, reject) {\n    const fieldValue = get(data, field)\n    if (skippable(fieldValue)) {\n      resolve('validation skipped')\n      return\n    }\n\n    if (Raw.string(fieldValue)) {\n      resolve('validation passed')\n      return\n    }\n    reject(message)\n  })\n}\n\n/**\n * aliases\n */\nValidations.between = Validations.range\n","/home/travis/build/npmtest/node-npmtest-indicative/node_modules/indicative/src/Raw/index.js":"'use strict'\n\n/**\n * indicative\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n*/\n\nconst moment = require('moment')\n\n/**\n * list of creepy regex, no they work nice\n */\nconst urlRegex = /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,63}\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*)/i\nconst emailRegex = /^([\\w-]+(?:\\.[\\w-]+)*)(\\+[\\w\\.-]+)?@((?:[\\w-]+\\.)*\\w[\\w-]{0,66})\\.([a-z]{2,63}(?:\\.[a-z]{2})?)$/i\nconst phoneRegex = /\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b/\nconst creditCardRegex = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|6(?:011|5[0-9]{2})[0-9]{12}|(?:2131|1800|35\\d{3})\\d{11})$/\nconst alphaNumericRegex = /^[a-z0-9]+$/i\nconst alphaRegex = /^[a-z]+$/i\nconst ipv4Regex = /^(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])(?:\\.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])){3}$/\nconst ipv6Regex = /^(?:(?:[0-9a-fA-F:]){1,4}(?:(?::(?:[0-9a-fA-F]){1,4}|:)){2,7})+$/\n\nlet Raw = exports = module.exports = {}\n\n/**\n * @description tells whether input is a valid\n * array or not\n * @method array\n * @param  {Mixed} input\n * @return {Boolean}\n * @public\n */\nRaw.array = function (input) {\n  return input instanceof Array\n}\n\n/**\n * @description tells whether input is a valid\n * boolean or not\n * @method boolean\n * @param  {Mixed} input\n * @return {Boolean}\n * @public\n */\nRaw.boolean = function (input) {\n  if (input === 0) {\n    input = false\n  } else if (input === 1) {\n    input = true\n  }\n  return typeof (input) === 'boolean'\n}\n\n/**\n * @description tells whether input is a valid\n * date or not\n * @method date\n * @param  {Mixed} input\n * @param  {Boolean} strict\n * @return {Boolean}\n * @example\n *   date(new Date())\n *   date(\"2015-11-30\") strict needs to be disabled\n * @public\n */\nRaw.date = function (input, strict) {\n  const isDateInstance = input instanceof Date\n  if (!isDateInstance && !strict) {\n    return new Date(input).toString() !== 'Invalid Date'\n  }\n  return isDateInstance\n}\n\n/**\n * @description tells whether input is a valid function\n * or not\n * @method function\n * @param  {Mixed} input\n * @return {Boolean}\n * @public\n */\nRaw.function = function (input) {\n  return typeof (input) === 'function'\n}\n\n/**\n * @description tells whether input is null\n * or not\n * @method null\n * @param  {Mixed} input\n * @return {Boolean}\n * @public\n */\nRaw.null = function (input) {\n  return input === null\n}\n\n/**\n * @description tells type of input is\n * a valid number or not\n * @method number\n * @param  {Mixed} input\n * @return {Boolean}\n * @public\n */\nRaw.number = function (input) {\n  return typeof (input) === 'number'\n}\n\n/**\n * @description tells whether input is a valid\n * object or not\n * @method object\n * @param  {Mixed} input\n * @return {Boolean}\n * @public\n */\nRaw.object = function (input) {\n  return input instanceof Object && !Raw.array(input)\n}\n\n/**\n * @description tells whether input is a valid\n * JSON string or not\n * @method json\n * @param  {Mixed} input\n * @return {Boolean}\n * @public\n */\nRaw.json = function (input) {\n  try {\n    JSON.parse(input)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\n/**\n * @description tells whether input is of type\n * string or not\n * @method string\n * @param  {Mixed} input\n * @return {Boolean}\n * @public\n */\nRaw.string = function (input) {\n  return typeof (input) === 'string'\n}\n\n/**\n * @description matches 2 input are of same type or\n * not\n * @method sameType\n * @param  {Mixed} input\n * @param  {Mixed} comparsionInput\n * @return {Boolean}\n * @public\n */\nRaw.sameType = function (input, comparsionInput) {\n  return typeof (input) === typeof (comparsionInput)\n}\n\n/**\n * @description tells whether input exists or not\n * @method existy\n * @param  {Mixed} input\n * @return {Boolean}\n * @example\n *   Following returns to false\n *   null\n *   undefined\n *   Empty string\n *  @public\n */\nRaw.existy = function (input) {\n  if (typeof (input) === 'string') {\n    return input.length > 0\n  }\n  return (input !== null && input !== undefined)\n}\n\n/**\n * @description tells whether input is truthy or\n * not\n * @method truthy\n * @param  {Mixed} input\n * @return {Boolean}\n * @example\n *   exists need to true\n *   not false\n *   not 0\n *  @public\n */\nRaw.truthy = function (input) {\n  return Raw.existy(input) && input !== false && input !== 0\n}\n\n/**\n * @description tells whether input is falsy or not, opposite\n * of truthy\n * @method falsy\n * @param  {Mixed} input\n * @return {Boolean}\n * @public\n */\nRaw.falsy = function (input) {\n  return !Raw.truthy(input)\n}\n\n/**\n * @description tells whether input is empty or not\n * @method empty\n * @param  {Mixed} input\n * @return {Boolean}\n * @example\n *   Following yield to true\n *    empty({})\n *    empty([])\n *    empty('')\n *    empty(null)\n *    empty(undefined)\n */\nRaw.empty = function (input) {\n  if (!Raw.existy(input)) {\n    return true\n  }\n\n  if (Raw.date(input)) {\n    return false\n  }\n\n  const type = typeof (input)\n\n  switch (type) {\n    case 'object' :\n      return Object.keys(input).length === 0\n    case 'string' :\n      return input.length === 0\n  }\n}\n\n/**\n * @description executes a given regex on a given input\n * @method regex\n * @param  {String} input\n * @param  {Regex} regex\n * @return {Boolean}\n * @public\n */\nRaw.regex = function (input, regex) {\n  return regex.test(input)\n}\n\n/**\n * @description tells whether given input is a valid url\n * or not\n * @method url\n * @param  {String} input\n * @return {Boolean}\n * @example\n *   Following yields to true\n *   http://foo.com\n *   https://foo.com\n *   http://foo.co.in\n *  @public\n */\nRaw.url = function (input) {\n  return Raw.regex(input, urlRegex)\n}\n\n/**\n * @description tells whether given input is a valid email\n * address or not\n * @method email\n * @param  {String} input\n * @return {Boolean}\n * @public\n */\nRaw.email = function (input) {\n  return Raw.regex(input, emailRegex)\n}\n\n/**\n * @description tells whether given input is a valid phone\n * number or not\n * @method phone\n * @param  {Number} input\n * @return {Boolean}\n * @example\n *   Following yield to true\n *   1235554567\n *   444-555-1234\n *   246.555.8888\n * @public\n */\nRaw.phone = function (input) {\n  return Raw.regex(input, phoneRegex)\n}\n\n/**\n * @description tells whether input is a valid credit card\n * number or not\n * @method creditCard\n * @param  {String}   input\n * @return {Boolean}\n * @example\n *   Works for\n *   Visa\n *   MasterCard\n *   American Express\n *   Diners Club\n *   Discover\n *   JCB\n *  @public\n */\nRaw.creditCard = function (input) {\n  input = input.replace(/-/g, '')\n  return Raw.regex(input, creditCardRegex)\n}\n\n/**\n * @description makes sure given field contains\n * letters only\n * @method alpha\n * @param  {String} input\n * @return {Boolean}\n * @public\n */\nRaw.alpha = function (input) {\n  return Raw.regex(input, alphaRegex)\n}\n\n/**\n * @description tells whether input is a valid alpha numeric\n * string or not\n * @method alphaNumeric\n * @param  {String|Number}     input\n * @return {Boolean}\n * @public\n */\nRaw.alphaNumeric = function (input) {\n  return Raw.regex(input, alphaNumericRegex)\n}\n\n/**\n * @description tells whether input is affirmative or\n * not\n * @method affirmative\n * @param  {String}    input\n * @return {Boolean}\n * @example\n *   Following yields true\n *   yes, true, y, ok, okay, A\n *  @public\n */\nRaw.affirmative = function (input) {\n  const affirmativeArray = ['yes', 'true', 'y', 'ok', 'okay']\n  if (input === 'A') {\n    return true\n  }\n  return affirmativeArray.indexOf(input.toLowerCase()) > -1\n}\n\n/**\n * @description tells whether ip address is a valid ipv4 ip\n * address\n * @method ipv4\n * @param  {String} input\n * @return {Boolean}\n * @public\n */\nRaw.ipv4 = function (input) {\n  return Raw.regex(input, ipv4Regex)\n}\n\n/**\n * @description tells whether ip address is a valid ipv6 ip\n * address\n * @method ipv6\n * @param  {String} input\n * @return {Boolean}\n * @public\n */\nRaw.ipv6 = function (input) {\n  return Raw.regex(input, ipv6Regex)\n}\n\n/**\n * @description tells whether ip address is a valid ipv4 or\n * ipv6 ip address\n * @method ip\n * @param  {String} input\n * @return {Boolean}\n * @public\n */\nRaw.ip = function (input) {\n  return Raw.ipv4(input) || Raw.ipv6(input)\n}\n\n/**\n * @description tells whether 2 values are identically same\n * @method same\n * @param  {Mixed} input\n * @param  {Mixed} comparsionInput\n * @return {Boolean}\n * @public\n */\nRaw.same = function (input, comparsionInput) {\n  return input === comparsionInput\n}\n\n/**\n * @description tells whether input is a even number or\n * not\n * @method even\n * @param  {Number} input\n * @return {Boolean}\n * @public\n */\nRaw.even = function (input) {\n  return Number(input) % 2 === 0\n}\n\n/**\n * @description tells whether input is a odd number or\n * not\n * @method odd\n * @param  {Number} input\n * @return {Boolean}\n * @public\n */\nRaw.odd = function (input) {\n  return !Raw.even(input)\n}\n\n/**\n * @description tells whether input is a positive number or not\n * @method positive\n * @param  {Number} input\n * @return {Boolean}\n * @public\n */\nRaw.positive = function (input) {\n  return Number(input) >= 0\n}\n\n/**\n * @description tells whether input is a negative number or not\n * @method negative\n * @param  {Number} input\n * @return {Boolean}\n * @public\n */\nRaw.negative = function (input) {\n  return !Raw.positive(input)\n}\n\n/**\n * @description tells whether input is above comparison\n * input\n * @method above\n * @param  {Number} input\n * @param  {Number} comparsionInput\n * @return {Boolean}\n * @public\n */\nRaw.above = function (input, comparsionInput) {\n  return Number(input) > Number(comparsionInput)\n}\n\n/**\n * @description tells whether input is under comparison\n * input\n * @method under\n * @param  {Number} input\n * @param  {Number} comparsionInput\n * @return {Boolean}\n * @public\n */\nRaw.under = function (input, comparsionInput) {\n  return !Raw.above(input, comparsionInput)\n}\n\n/**\n * @description tells whether a value lies between 2 values\n * or not\n * @method between\n * @param  {Number} input\n * @param  {Number} min\n * @param  {Number} max\n * @return {Boolean}\n * @public\n */\nRaw.between = function (input, min, max) {\n  input = Number(input)\n  return (input > Number(min)) && (input < Number(max))\n}\n\n/**\n * @description tells whether a value lies in an array or\n * not\n * @method inArray\n * @param  {String} input\n * @param  {Array} comparsionArray\n * @return {Boolean}\n * @public\n */\nRaw.inArray = function (input, comparsionArray) {\n  const isArrayInstance = comparsionArray instanceof Array\n  if (!isArrayInstance) {\n    return false\n  }\n  return comparsionArray.indexOf(input) > -1\n}\n\n/**\n * @description tells whether an array is sorted or not\n * @method sorted\n * @param  {Array} input\n * @return {Boolean}\n * @public\n */\nRaw.sorted = function (input) {\n  const isArrayInstance = input instanceof Array\n  let downScale = 0\n  if (!isArrayInstance) {\n    return false\n  }\n  input.sort(function (a, b) {\n    if (a > b) {\n      downScale++\n      return\n    }\n  })\n  return downScale === 0\n}\n\n/**\n * @description tells whether input date is a valid date\n * is today or not\n * @method today\n * @param  {String|Object} input\n * @return {Boolean}\n * @example\n *   accepts\n *   2015-11-30\n *   new Date()\n * @public\n */\nRaw.today = function (input) {\n  const today = moment().format('YYYY-MM-DD')\n  const inputDate = moment(input).format('YYYY-MM-DD')\n  return inputDate === today\n}\n\n/**\n * @description tells whether input date is a valid date\n * from yesterday or not\n * @method yesterday\n * @param  {String|Object}  input\n * @return {Boolean}\n * @example\n *   accepts\n *   2015-11-30\n *   new Date()\n * @public\n */\nRaw.yesterday = function (input) {\n  const yesterday = moment().subtract(1, 'days').format('YYYY-MM-DD')\n  const inputDate = moment(input).format('YYYY-MM-DD')\n  return inputDate === yesterday\n}\n\n/**\n * @description tells whether input date is a valid date\n * to tomorrow or not\n * @method tomorrow\n * @param  {String|Object}  input\n * @return {Boolean}\n * @example\n *   accepts\n *   2015-11-30\n *   new Date()\n * @public\n */\nRaw.tomorrow = function (input) {\n  const tomorrow = moment().add(1, 'days').format('YYYY-MM-DD')\n  const inputDate = moment(input).format('YYYY-MM-DD')\n  return inputDate === tomorrow\n}\n\n/**\n * @description tells whether input date is in past or not\n * @method past\n * @param  {String|Object}  input\n * @return {Boolean}\n * @example\n *   accepts\n *   2015-11-30\n *   new Date()\n * @public\n */\nRaw.past = function (input) {\n  return moment().isAfter(input, 'date')\n}\n\n/**\n * @description tells whether input date is in future or not\n * @method future\n * @param  {String|Object}  input\n * @return {Boolean}\n * @example\n *   accepts\n *   2015-11-30\n *   new Date()\n * @public\n */\nRaw.future = function (input) {\n  return !Raw.past(input)\n}\n\n/**\n * @description tells whether input is after given date\n * @method after\n * @param  {String|Object} input\n * @param  {String|Object} afterDate\n * @return {Boolean}\n * @example\n *   accepts\n *   2015-11-30\n *   new Date()\n * @public\n */\nRaw.after = function (input, afterDate) {\n  return moment(input).isAfter(afterDate)\n}\n\n/**\n * @description tells whether input is after certain\n * offset from current date\n * @method afterOffsetOf\n * @param  {String}      input\n * @param  {Number}      number\n * @param  {String}      key\n * @return {Boolean}\n * @example\n *   key can be\n *     years        | y\n *     quarters     | Q\n *     months       | M\n *     weeks        | w\n *     days         | d\n *     hours        | h\n *     minutes      | m\n *     seconds      | s\n *     milliseconds | ms\n * @public\n */\nRaw.afterOffsetOf = function (input, number, key) {\n  const afterDate = moment().add(number, key)\n  return moment(input).isAfter(afterDate)\n}\n\n/**\n * @description tells whether input is before certain\n * offset from current date\n * @method beforeOffsetOf\n * @param  {String}      input\n * @param  {Number}      number\n * @param  {String}      key\n * @return {Boolean}\n * @example\n *   key can be\n *     years        | y\n *     quarters     | Q\n *     months       | M\n *     weeks        | w\n *     days         | d\n *     hours        | h\n *     minutes      | m\n *     seconds      | s\n *     milliseconds | ms\n * @public\n */\nRaw.beforeOffsetOf = function (input, number, key) {\n  const beforeDate = moment().subtract(number, key)\n  return moment(input).isBefore(beforeDate)\n}\n\n/**\n * @description tells whether input is before a given date\n * @method before\n * @param  {String|Object} input\n * @param  {String|Object} beforeDate\n * @return {Boolean}\n * @example\n *   accepts\n *   2015-11-30\n *   new Date()\n * @public\n */\nRaw.before = function (input, beforeDate) {\n  return moment(input).isBefore(beforeDate)\n}\n\n/**\n * @description tells whether input is a valid date for a given\n * format or not\n * @method dateFormat\n * @param  {String}  input\n * @param  {Array}  formats\n * @param  {String}  locale\n * @return {Boolean}\n * @example\n *   accepts\n *   2015-11-30\n * @public\n */\nRaw.dateFormat = function (input, formats, locale) {\n  locale = locale || 'en'\n  return moment(input, formats, locale, true).isValid()\n}\n\n/**\n * @description tells whether a given date is between 2 dates or not\n * @method inDateRange\n * @param  {String}    input\n * @param  {String}    minDate\n * @param  {String}    maxDate\n * @return {Boolean}\n * @example\n *   accepts\n *   2015-11-30\n *   new Date()\n * @public\n */\nRaw.inDateRange = function (input, minDate, maxDate) {\n  return moment(input).isBetween(minDate, maxDate)\n}\n\n/**\n * @description makes sure any one value of one array\n * is present in another array\n * @method intersectAny\n * @param  {Array}     input\n * @param  {Array}     intersectionArray\n * @return {Boolean}\n */\nRaw.intersectAny = function (input, intersectionArray) {\n  const isArrayInstance = input instanceof Array\n  const isIntersectionArrayInstance = intersectionArray instanceof Array\n  let matchesCount = 0\n\n  if (!isArrayInstance || !isIntersectionArrayInstance) {\n    return false\n  }\n\n  input.filter(function (n) {\n    if (intersectionArray.indexOf(n) > -1) {\n      matchesCount++\n      return\n    }\n  })\n  return matchesCount > 0\n}\n\n/**\n * @description makes sure all values of one array are\n * present in another array\n * @method intersectAll\n * @param  {Array}     input\n * @param  {Array}     intersectionArray\n * @return {Boolean}\n */\nRaw.intersectAll = function (input, intersectionArray) {\n  const isArrayInstance = input instanceof Array\n  const isIntersectionArrayInstance = intersectionArray instanceof Array\n  let matchesCount = 0\n\n  if (!isArrayInstance || !isIntersectionArrayInstance) {\n    return false\n  }\n\n  input.filter(function (n) {\n    if (intersectionArray.indexOf(n) > -1) {\n      matchesCount++\n    }\n  })\n\n  return matchesCount === input.length\n}\n","/home/travis/build/npmtest/node-npmtest-indicative/node_modules/indicative/src/Modes/index.js":"'use strict'\n\n/**\n * indicative\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n*/\n\nconst availableModes = ['normal', 'strict']\nlet currentMode = 'normal'\n\nconst Modes = exports = module.exports = {}\n\nModes.set = function (mode) {\n  if (availableModes.indexOf(mode) <= -1) {\n    console.log(`indicative: ${mode} is not a valid mode, switching back to normal mode`)\n    return\n  }\n  currentMode = mode\n}\n\nModes.get = function () {\n  return currentMode\n}\n","/home/travis/build/npmtest/node-npmtest-indicative/node_modules/indicative/src/Validator/engine.js":"'use strict'\n\n/**\n * indicative\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n*/\n\nconst Validations = require('../Validations')\nconst Messages = require('../Messages')\nconst _ = require('lodash')\nconst Q = require('q')\n\nconst ValidationEngine = exports = module.exports = {}\n\n/**\n * validates a field with all assigned validations for that\n * field.\n *\n * @param  {Object}  data\n * @param  {String}  field\n * @param  {Object}  validations\n * @param  {Object}  messages\n * @param  {Boolean} [runAll]\n *\n * @return {Promise<Array>}\n */\nValidationEngine.validateField = function (data, field, validations, messages, runAll) {\n  const method = runAll ? 'allSettled' : 'all'\n  return Q[method](\n    _.map(validations, (validation) => {\n      return ValidationEngine.runValidationOnField(data, field, validation.name, messages, validation.args)\n    })\n  )\n}\n\n/**\n * runs a single validation on a given field.\n *\n * @param  {Object} data\n * @param  {String} field\n * @param  {String} validation\n * @param  {Object} messages\n * @param  {Array}  [args]\n *\n * @return {Promise}\n */\nValidationEngine.runValidationOnField = function (data, field, validation, messages, args) {\n  const message = Messages.make(messages, field, validation, args)\n  const validationMethod = ValidationEngine.getValidationMethod(validation)\n\n  return Q.Promise((resolve, reject) => {\n    validationMethod(data, field, message, args, _.get)\n    .then(resolve)\n    .catch((error) => {\n      reject({field, validation, message: error})\n    })\n  })\n}\n\n/**\n * returns the validation method from the Validations\n * store or throws an error saying validation not\n * found.\n *\n * @param  {String} validation\n *\n * @return {Function}\n *\n * @throws {Error} If validation is not found\n */\nValidationEngine.getValidationMethod = function (validation) {\n  return _.get(Validations, _.camelCase(validation), function () {\n    throw new Error(`${validation} is not defined as a validation`)\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-indicative/node_modules/indicative/src/Messages/index.js":"'use strict'\n\n/**\n * indicative\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n*/\nconst pope = require('pope')\nconst _ = require('lodash')\n\nconst messagesStore = {}\nconst arrayExpressionRegex = /\\.\\d/g\n\n/**\n * returns the default message for a validation.\n *\n * @param   {Object} messages\n * @param   {String} field\n * @param   {String} validation\n *\n * @return  {String}\n *\n * @private\n */\nfunction _returnDefaultMessage (messages, field, validation) {\n  return messagesStore[validation] || '{{validation}} validation failed on {{field}}'\n}\n\n/**\n * returns a custom validation message for a given validation.\n *\n * @param   {Object} messages\n * @param   {String} field\n * @param   {String} validation\n *\n * @return  {String|Function}\n *\n * @private\n */\nfunction _returnValidationMessage (messages, field, validation) {\n  return messages[validation]\n}\n\n/**\n * returns a custom validation message for a given field\n * and validation\n *\n * @param   {Object} messages\n * @param   {String} field\n * @param   {String} validation\n *\n * @return  {String|Function}\n *\n * @private\n */\nfunction _returnFieldValidationMessage (messages, field, validation) {\n  const fieldToArrayExpression = field.replace(arrayExpressionRegex, '.*')\n  return messages[`${field}.${validation}`] || messages[`${fieldToArrayExpression}.${validation}`]\n}\n\n/**\n * returns the message method.\n *\n * @param   {Function|String} message\n *\n * @return  {String}\n *\n * @private\n */\nfunction _makePopeMessage (message) {\n  return typeof (message) === 'function' ? message : function (field, validation, arg) {\n    return pope(message, {field, validation, argument: arg})\n  }\n}\n\n/**\n * a custom array holding all the validation message\n * functions. We will later itterate over this\n * array to find the best message.\n *\n * @type {Array}\n */\nconst validationMethods = [\n  _returnFieldValidationMessage,\n  _returnValidationMessage,\n  _returnDefaultMessage\n]\n\nlet Messages = exports = module.exports = {}\n\n/**\n * making a message for a given field and validation.\n *\n * @param  {Object} customMessages\n * @param  {String} field\n * @param  {String} validation\n * @param  {Array} args\n *\n * @return {String}\n */\nMessages.make = function (customMessages, field, validation, args) {\n  return _(validationMethods)\n  .chain()\n  .find((method) => method(customMessages, field, validation))\n  .thru((method) => method(customMessages, field, validation))\n  .thru((message) => _makePopeMessage(message)(field, validation, args))\n  .value()\n}\n\n/**\n * @description sets a message for a given rule\n * @method set\n * @param  {String} name\n * @param  {String|Function} message\n * @public\n */\nMessages.set = function (name, message) {\n  messagesStore[name] = message\n}\n","/home/travis/build/npmtest/node-npmtest-indicative/node_modules/indicative/src/Sanitization/index.js":"'use strict'\n\n/**\n * indicative\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n*/\n\nlet Sanitization = exports = module.exports = {}\n\nconst _ = require('lodash')\nconst Parser = require('../Parser')\nconst filters = require('./filters')\n\n/**\n * returns sanitization method for a filter name\n *\n * @param   {String} filter\n *\n * @return  {Function}        [description]\n *\n * @throws {Error} If filter is not found\n *\n * @private\n */\nfunction _getSanitizationMethod (filter) {\n  return _.get(filters, _.camelCase(filter), function () {\n    throw new Error(`${filter} is not defined as a filter`)\n  })\n}\n\n/**\n * sanitizes a given field value by looping over\n * all the rules defined next to the field.\n *\n * @param   {Object} data\n * @param   {Array} rules\n * @param   {String} field\n *\n * @return  {String}\n *\n * @private\n */\nfunction _sanitizeFieldValue (data, rules, field) {\n  return _.reduce(rules, (value, rule) => {\n    const ruleMethod = _getSanitizationMethod(rule.name)\n    return ruleMethod(value, rule.args)\n  }, _.get(data, field))\n}\n\n/**\n * sanitizes a given set of data with given set\n * of rules.\n *\n * @param  {Object} data\n * @param  {Object} rules\n *\n * @return {Object}\n */\nSanitization.sanitize = function (data, rules) {\n  const clonedSet = _.cloneDeep(data)\n  const transformedRules = Parser.transformRules(data, rules)\n  return _.reduce(transformedRules, (result, rules, field) => {\n    _.set(result, field, _sanitizeFieldValue(data, rules, field))\n    return result\n  }, clonedSet)\n}\n\nSanitization.sanitizor = filters\n\n/**\n * exposes an interface to extend filters\n *\n * @param  {String} name\n * @param  {Function} method\n *\n * @return {void}\n *\n * @throws {Error} If method is not a function\n */\nSanitization.sanitizor.extend = function (name, method) {\n  if (typeof (method) !== 'function') {\n    throw new Error('Invalid arguments, sanitizor.extend expects 2nd parameter to be a function')\n  }\n  Sanitization.sanitizor[name] = method\n}\n","/home/travis/build/npmtest/node-npmtest-indicative/node_modules/indicative/src/Sanitization/filters.js":"'use strict'\n\n/**\n * indicative\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n*/\n\nconst domains = /^hotmail\\.com|gmail\\.com|live\\.com$/\nconst linksRegex = /<a\\b[^>]*>(.*?)<\\/a>/ig\nconst tagsRegex = /<\\/?[^>]+(>|$)/g\n\nconst inflect = require('inflect')\n\nlet SanitizationFilters = exports = module.exports = {}\n\n/**\n * @description tells whether domain falls in one of the\n * normalized providers or not\n * @method _isNormalizeableProvider\n * @param  {String}                 domain\n * @return {Boolean}\n */\nfunction _isNormalizeableProvider (domain) {\n  return domains.test(domain)\n}\n\n/**\n * @description tells whether email is hotmail or not\n * @method _isHotmail\n * @param  {String}   domain\n * @return {Boolean}\n * @private\n */\nfunction _isHotmail (domain) {\n  return /hotmail\\.com$/.test(domain)\n}\n\n/**\n * @description replaces a pattern with a substitue\n * only if value is a string\n * @method _replace\n * @param  {Mixed} value\n * @param  {Regex} pattern\n * @param  {String|Function} subsitute\n * @return {Mixed}\n * @private\n */\nfunction _replace (value, pattern, subsitute) {\n  if (typeof (value) !== 'string') {\n    return value\n  }\n  return value.replace(pattern, subsitute)\n}\n\n/**\n * @description removes blacklisted values from string\n * @method blacklist\n * @param  {String}  value\n * @param  {Array}  args\n * @return {String}\n * @public\n */\nSanitizationFilters.blacklist = function (value, args) {\n  const blacklistRegex = new RegExp(`[${args[0]}]`, 'g')\n  return _replace(value, blacklistRegex, '')\n}\n\n/**\n * @description escapes an input if it's string\n * @method escape\n * @param  {String} value\n * @return {String}\n * @public\n */\nSanitizationFilters.escape = function (value) {\n  if (typeof (value) !== 'string') {\n    return value\n  }\n\n  return (\n  value\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#x27;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\\//g, '&#x2F;')\n    .replace(/\\//g, '&#96;')\n  )\n}\n\n/**\n * @description normalizes an email by removing all unncessary\n * characters from it\n * @method normalizeEmail\n * @param  {String}       value\n * @param  {Array}       args\n * @return {String}\n * @public\n */\nSanitizationFilters.normalizeEmail = function (value, args) {\n  const options = {\n    lowercase: true,\n    removeDots: true,\n    removeExtension: true\n  }\n\n  if (args instanceof Array) {\n    args.forEach(function (option) {\n      if (option === '!lc') {\n        options.lowercase = false\n      }\n      if (option === '!rd') {\n        options.removeDots = false\n      }\n      if (option === '!re') {\n        options.removeExtension = false\n      }\n    })\n  }\n\n  if (typeof (value) !== 'string') {\n    return value\n  }\n\n  const splitValue = value.split('@')\n\n  if (!splitValue[1]) {\n    return value\n  }\n\n  let username = options.lowercase ? splitValue[0].toLowerCase() : splitValue[0]\n  const domain = splitValue[1] === 'googlemail.com' ? 'gmail.com' : splitValue[1].toLowerCase()\n\n  if (options.removeExtension && _isNormalizeableProvider(domain)) {\n    username = username.split('+')[0]\n  }\n\n  if (options.removeDots && !_isHotmail(domain)) {\n    username = username.replace(/\\./g, '')\n  }\n\n  return `${username}@${domain}`\n}\n\n/**\n * @description coverts a value to boolean all values\n * with positive inputs yields to true\n * @method toBoolean\n * @param  {Mixed}  value\n * @return {Boolean}\n * @public\n */\nSanitizationFilters.toBoolean = function (value) {\n  if (!value || value === 'false' || value === '0') {\n    return false\n  }\n  return true\n}\n\n/**\n * @description converts a value to float or returns\n * NaN when unable to make it a flat\n * @method toFloat\n * @param  {Mixed} value\n * @return {Float}\n * @public\n */\nSanitizationFilters.toFloat = function (value) {\n  return parseFloat(value)\n}\n\n/**\n * @description coverts a value to integer or returns\n * NaN\n * @method toInt\n * @param  {Mixed} value\n * @param  {Array} args\n * @return {Integer}\n * @public\n */\nSanitizationFilters.toInt = function (value, args) {\n  const radix = typeof (args[0]) === 'number' ? args[0] : 10\n  return parseInt(value, radix)\n}\n\n/**\n * @desription converts a date to a date object or\n * return null when invalid date\n * @method toDate\n * @param  {Mixed} value\n * @return {String}\n */\nSanitizationFilters.toDate = function (value) {\n  const dateValue = new Date(value)\n  return (dateValue.toString() === 'Invalid Date') ? null : dateValue\n}\n\n/**\n * @description strips a tags from string\n * @method stripLinks\n * @param  {String}   value\n * @return {String}\n * @public\n */\nSanitizationFilters.stripLinks = function (value) {\n  return _replace(value, linksRegex, function (index, group) {\n    return group.trim()\n  })\n}\n\n/**\n * @description strips html tags from a give value\n * and also removes unwanted spaces if trim is\n * set to true\n * @method stripTags\n * @param  {String}  value\n * @param  {Array}  args\n * @return {String}\n * @public\n */\nSanitizationFilters.stripTags = function (value, args) {\n  const strict = (args[0] && args[0] === 'trim')\n  value = _replace(value, tagsRegex, '')\n  if (strict) {\n    value = _replace(value, /\\s+/g, ' ')\n  }\n  return typeof (value) === 'string' ? value.trim() : value\n}\n\nSanitizationFilters.plural = function (value) {\n  return inflect.pluralize(value)\n}\n\nSanitizationFilters.singular = function (value) {\n  return inflect.singularize(value)\n}\n\nSanitizationFilters.camelCase = function (value) {\n  return inflect.camelize(value)\n}\n\nSanitizationFilters.capitalize = function (value) {\n  return inflect.capitalize(value)\n}\n\nSanitizationFilters.decapitalize = function (value) {\n  return inflect.decapitalize(value)\n}\n\nSanitizationFilters.title = function (value) {\n  return inflect.titleize(value)\n}\n\nSanitizationFilters.underscore = function (value) {\n  return inflect.underscore(value)\n}\n\nSanitizationFilters.toDash = function (value) {\n  return inflect.dasherize(value)\n}\n\nSanitizationFilters.slug = function (value) {\n  return inflect.parameterize(value)\n}\n\nSanitizationFilters.humanize = function (value) {\n  return inflect.humanize(value)\n}\n"}